# ChatGPT Codex Integration Guide

## Проект Context для ChatGPT Codex

Это React/TypeScript приложение с уникальной **манифест-ориентированной архитектурой** для создания
флэшкарт из латышского текста. Ключевая особенность: полное исключение race conditions через
детерминированный манифест.

### Архитектурная парадигма:

- Манифест создается ДО отправки к LLM и содержит канонический порядок
- LLM ответы = аннотации к предложениям манифеста
- Агрегация всегда происходит по SID, не по порядку получения

## Workflow для ChatGPT Codex

### 1. Начало работы:

- ВСЕГДА начинай с изучения @AGENT.md
- Изучи архитектурные принципы в @src/types/manifest.ts
- Пойми FSM в @src/utils/fsm.ts

### 2. Перед любыми изменениями:

- Проверь что понимаешь поток данных: Text → Manifest → LLM → DTO → Aggregation
- Убедись что изменение не нарушает принцип "manifest-first"
- Проверь совместимость с существующими DTO схемами

### 3. При добавлении нового функционала:

- Начни с определения типов в src/types/
- Добавь соответствующие Zod схемы для валидации
- Напиши тесты ДО реализации (TDD подход)
- Обнови FSM если нужны новые состояния

## ChatGPT-5 Thinking Prompts

### Для архитектурных изменений:

```
Проанализируй как это изменение влияет на манифест-ориентированную архитектуру:
1. Сохраняется ли принцип "манифест как источник истины"?
2. Не нарушаются ли инварианты SID и порядка предложений?
3. Совместимо ли с FSM переходами состояний?
4. Требуется ли обновление DTO схем?
```

### Для отладки проблем:

```
Используй принципы для избежания  ошибок:
1. Проверь состояние FSM - где сейчас находится система?
2. Валидируй манифест - корректны ли SID и сигнатуры?
3. Проследи агрегацию по SID - правильно ли группируются данные?
4. Проверь DTO валидацию - соответствуют ли данные схеме?
```

### Для создания тестов:

```
Создай golden test который проверяет критический инвариант:
Входной текст → (любой порядок JSONL) → агрегация по SID → сборка === исходный порядок

Используй property-based тесты для проверки:
- Перестановки JSONL строк не влияют на результат
- Дубликаты/пропуски SID обрабатываются корректно
- Все возможные FSM переходы детерминированы
```

## File References для понимания архитектуры

### Ключевые файлы (изучи в этом порядке):

- **@src/types/manifest.ts** - типы манифеста и SID
- **@src/types/dto.ts** - API контракты и Zod схемы
- **@src/utils/manifest.ts** - создание детерминированного манифеста
- **@src/utils/aggregator.ts** - агрегация результатов по SID
- **@src/utils/fsm.ts** - машина состояний для UI
- **@src/hooks/useBatch.ts** - оркестрация batch обработки

### Файлы проблем для избежания ошибок:

- **@src/**tests**/golden/** - критические инварианты которые нельзя нарушать

## Специальные инструкции для ChatGPT Codex

### При работе с манифестом:

- Манифест создается ОДИН раз при инициализации
- SID назначаются последовательно: 0, 1, 2, ...
- Сигнатуры создаются как base64(normalized_text + "#" + sid)
- LV текст ВСЕГДА восстанавливается из manifest.items.map(i => i.lv)

### При работе с агрегацией:

- Используй Map<number, ResultData> где ключ = SID
- НИКОГДА не полагайся на порядок приходящих данных
- Каноникализация RU: pickCanonical() выбирает лучший вариант перевода
- Собирай итоговый RU текст по порядку SID из манифеста

### При работе с FSM:

- UI состояние = проекция состояний FSM
- Переходы: idle → submitted → in_progress → ready/failed
- НИКОГДА не используй прямые setState для состояния батча
- Все события FSM явно типизированы

## Debugging Guide для Codex

### Если порядок предложений нарушен:

1. Проверь что LV собирается из `manifest.items.map(i => i.lv)`
2. Убедись что RU собирается по порядку SID из манифеста
3. Найди где происходит агрегация не по SID

### Если появляются race conditions:

1. Проверь что нет прямых обращений к результатам LLM для порядка
2. Убедись что FSM используется для всех переходов состояний
3. Проверь что компоненты не имеют собственного async состояния

### Если тесты падают:

1. Запусти golden тесты: `npm run test:golden`
2. Проверь что инварианты манифеста не нарушены
3. Валидируй что DTO схемы соответствуют данным
