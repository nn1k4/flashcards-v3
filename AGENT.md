# Flashcards Generator v3 - AI Agent Configuration

## Проект Overview

Манифест-ориентированная React/TypeScript архитектура для создания флэшкарт из латышского текста. Основной принцип: **порядок предложений фиксируется в манифесте до вызова LLM, ответы модели служат только аннотациями**.

### Ключевые архитектурные принципы:
- **Манифест как источник истины** - LV текст восстанавливается только из манифеста
- **Агрегация по SID** - результаты группируются по идентификаторам предложений
- **FSM управление состояниями** - все UI состояния выводятся из машины состояний
- **Жёсткие контракты** - все API используют типизированные DTO с версионированием

## Build & Commands

- Проверка типов: `npm run type-check`
- Запуск тестов: `npm run test`
- Золотые тесты: `npm run test:golden`
- Property-based тесты: `npm run test:property`
- Покрытие тестов: `npm run test:coverage`
- Dev сервер: `npm run dev`
- Сборка: `npm run build`
- Валидация всего: `npm run validate`

## Code Style для AI-агентов

- **TypeScript strict mode** с exactOptionalPropertyTypes и noUncheckedIndexedAccess
- **Функциональное программирование** предпочтительно над императивным
- **Immutable обновления** состояний через spread/структурное клонирование
- **Explicit инварианты** через assertions и runtime проверки
- **Комментарии на РУССКОМ языке** для объяснения бизнес-логики
- **Английские термины** только для технических концепций

### Именование:
- Компоненты: PascalCase (TextInput, BatchRunner)
- Функции/переменные: camelCase (buildManifest, aggregateBySid)
- Константы: SCREAMING_SNAKE_CASE (BATCH_STATES)
- Типы: PascalCase с префиксом T при необходимости

## Architecture для AI понимания

### Поток данных (КРИТИЧНО для понимания):
```
Исходный текст → Сплиттер → Манифест{sid,lv,sig} → LLM по чанкам
                                    ↑
LV из манифеста ← Агрегация по SID ← Валидация DTO ← JSONL ответы
RU по SID       ← Каноникализация ← 
```

### Модули и ответственность:
- **@src/types/** - контракты данных и доменные типы
- **@src/utils/manifest.ts** - создание и валидация манифеста
- **@src/utils/aggregator.ts** - агрегация результатов по SID  
- **@src/utils/fsm.ts** - машина состояний для батч-процесса
- **@src/api/client.ts** - HTTP клиент с Zod валидацией
- **@src/hooks/** - React хуки для бизнес-логики

## Testing Strategy для AI

### Типы тестов:
- **Золотые тесты** - проверяют что входной текст → JSONL → сборка даёт исходный порядок
- **Property-based тесты** - проверяют инварианты на случайных данных
- **Юнит тесты** - изолированное тестирование каждого модуля
- **Интеграционные тесты** - end-to-end сценарии

### Критические инварианты для тестирования:
- `lvFromManifest(manifest) === normalizeText(originalText)`
- Агрегация по SID не зависит от порядка JSONL строк
- FSM переходы детерминированы и без циклов
- DTO валидация отклоняет некорректные схемы

## Security & Invariants

### Runtime проверки (ОБЯЗАТЕЛЬНЫЕ):
- Валидация всех входящих DTO через Zod схемы
- Assertions для критических инвариантов манифеста
- Проверка сигнатур SID при агрегации результатов
- Типобезопасность на границах модулей

### Метрики для мониторинга:
- `schema_mismatch_count` - несоответствия версий схем
- `sig_mismatch_count` - несовпадения сигнатур SID
- `missing_ru_count` - отсутствующие переводы
- `order_violation_count` - нарушения порядка предложений

## Проблемы которые НЕЛЬЗЯ повторять

**КРИТИЧЕСКАЯ ИСТОРИЯ:**
- ❌ Race conditions при сборке переводов
- ❌ Источник порядка = ответ модели (нестабильный)
- ❌ Сборка LV/RU из карточек на UI-уровне  
- ❌ Отсутствие FSM → спонтанные setState
- ❌ Слабые контракты данных → постоянные коэрсы
- ❌ Отсутствие золотых тестов → незаметные регрессии

### При любых изменениях ВСЕГДА проверяй:
1. Не нарушается ли принцип "манифест как источник истины"?
2. Сохраняется ли детерминированность сборки текста?
3. Проходят ли золотые тесты на порядок предложений?
4. Валидируются ли все новые DTO схемы?

## ChatGPT-5 Thinking Optimization

### Мысленная модель для разработки:
При работе с этим проектом используй следующую последовательность мышления:
1. **Манифест первый** - всегда начинай с понимания манифеста
2. **SID как ключ** - всё агрегируется и собирается по SID
3. **FSM определяет UI** - состояние UI = проекция состояний FSM
4. **Инварианты как безопасность** - каждое изменение проверяется

### Процесс принятия решений:
Для каждого изменения в коде задавай вопросы:
- Сохраняет ли это детерминированность обработки?
- Нарушается ли какой-либо архитектурный инвариант?
- Покрыто ли изменение соответствующими тестами?
- Совместимо ли с FSM и агрегацией по SID?

### Debugging подход:
При возникновении проблем:
1. Проверь состояние FSM - в каком состоянии система?
2. Валидируй манифест - корректны ли SID и сигнатуры?
3. Проследи агрегацию - как данные группируются по SID?
4. Проверь DTO схемы - соответствуют ли данные ожидаемому формату?