# tool‑use

⚠️ Реализация в коде на стадии планирования. Схемы и политика ниже — нормативные, но ещё не
подключены.

## 1) Цель и рамки в нашем проекте

Мы используем **tools** в первую очередь как «JSON‑режим с гарантией схемы\*\*, без фактического
запуска сторонних действий. То есть модель **всегда** делает `tool_use` ровно одного «виртуального»
инструмента со строгой схемой, а мы считываем `input` из этого блока как готовый JSON
(карточки/контексты), **не отправляя `tool_result` обратно**. Такой режим официально поддержан: шаги
3–4 (выполнение и возврат результата) **опциональны** — иногда сам `tool_use` и есть нужный нам
JSON-ответ.&#x20;

**Почему так:**

- обеспечивает «**JSON‑only + Zod**» инвариант проекта; модель физически не сможет ответить
  свободным текстом — только через форму инструмента;
- упрощает детерминизм и повторяемость batch‑обработки (SID/манифест/порядок);
- избегает побочных эффектов и сторонних расходов на «серверные» инструменты.

> В терминах Anthropic это «JSON mode через tools»: один инструмент, форсированный `tool_choice`,
> описание — с точки зрения модели, которая «передаёт» нам объект `input`.&#x20;

---

## 2) Таксономия инструментов и что включаем/выключаем

- **Client tools** (выполняем сами: custom, text editor, computer use). Нам **не нужны** в основном
  UI; используем только «виртуальный» custom‑tool для JSON.&#x20;
- **Server tools** (выполняются у Anthropic: web search, code execution). В проде **выключены по
  умолчанию** ради детерминизма, цены и отсутствия внешних зависимостей; включаем только в локальных
  экспериментах (флаг в конфиге).&#x20;

> Anthropic‑инструменты имеют версионированные типы (`web_search_20250305`, `text_editor_20250728` и
> т.п.).&#x20;

---

## 3) Ключевые решения по управлению tool use

### 3.1 Форсируем ровно один инструмент

- `tool_choice: {"type":"tool","name":"emit_flashcards"}`
- `disable_parallel_tool_use: true` → гарантирует **ровно один** `tool_use`. Это упрощает парсинг и
  интеграцию с FSM/манифестом.&#x20;

> Поменяете `tool_choice` — инвалидируете кэш сообщений (tool‑definitions и system остаются
> кэшируемыми). Учитываем в Prompt Cache.&#x20;

### 3.2 «Token‑efficient tool use»

Фича (Sonnet 3.7, бета‑хедер) снижает латентность/стоимость при server‑tools, но **конфликтует** с
отключением параллелизма и не даёт нам пользы для JSON‑only. В нашем профиле **по умолчанию
выключено**. (Включать сознательно и только для задач с реальным server‑tool).&#x20;

### 3.3 Fine‑grained tool streaming

Даёт потоковую передачу параметров (`input_json_delta`), но может приходить **частичный/невалидный
JSON** → усложняет валидацию и не нужен при нашей UX‑модели (мы не показываем поток). Оставляем
**off**; в будущем — под экспериментальный флаг.&#x20;

---

## 4) Наш «виртуальный» инструмент: схема и контракт

### 4.1 Схема инструмента

Определяем единственный custom‑tool `emit_flashcards` со схемой из TRS (упрощённо):

```json
{
  "name": "emit_flashcards",
  "description": "Верни строго структурированный JSON набора карточек согласно схеме проекта. Никакого текста вне полей.",
  "input_schema": {
    "type": "object",
    "properties": {
      "flashcards": {
        "type": "array",
        "items": {
          "type": "object",
          "required": ["unit", "base_form", "contexts", "visible"],
          "properties": {
            "unit": { "type": "string", "enum": ["word", "phrase"] },
            "base_form": { "type": "string" },
            "base_translation": { "type": "string" },
            "contexts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["latvian", "russian", "forms"],
                "properties": {
                  "latvian": { "type": "string" },
                  "russian": { "type": "string" },
                  "forms": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": ["form", "translation"],
                      "properties": {
                        "form": { "type": "string" },
                        "translation": { "type": "string" }
                      }
                    }
                  }
                }
              }
            },
            "visible": { "type": "boolean" }
          }
        }
      }
    },
    "required": ["flashcards"],
    "additionalProperties": false
  }
}
```

> Подход «один инструмент + принудительный выбор» — канонический способ добиться JSON‑mode.&#x20;

### 4.2 Запрос

- В каждый `messages.create` передаём: `tools: [emit_flashcards]`,
  `tool_choice: {type:"tool", name:"emit_flashcards"}`, `disable_parallel_tool_use:true`; streaming
  = off.
- Модель вернёт `assistant.content` с блоком
  `{type:"tool_use", name:"emit_flashcards", input:{...}}`. Мы **читаем `input`**, валидируем Zod‑ом
  и сохраняем. Возврат `tool_result` **не требуется**.&#x20;

### 4.3 Форматирование (если когда‑то решим слать `tool_result`)

При параллельных вызовах (нам не нужно) **все** `tool_result` должны приходить **одним**
`user`‑сообщением, без текста до результатов. Это требование важно держать в голове для любых
будущих реальных инструментов.

---

## 5) Подсказки (prompting) для лучшей работы tools

- Дайте **подробное описание** инструмента (3–4+ предложения: что делает, когда использовать,
  значения параметров, ограничения). Это самый весомый фактор качества.&#x20;
- Для JSON‑режима: **один инструмент + `tool_choice: tool`**, имя/описание — «от лица модели» (она
  «вызывает» tool).&#x20;
- Если когда‑то оставляем `tool_choice: auto`, учтите влияние на chain‑of‑thought и что «forcing»
  лучше делать через `tool_choice`, а не только текстом.&#x20;

---

## 6) Интеграция с Prompt Caching

- Кэшируются system и tool‑definitions; изменение `tool_choice` **сбросит кэш блока сообщений**.
  Планируя кэш, держим `tool_choice` стабильным.&#x20;
- Для server web‑search есть пример мульти‑ходового кэша с `cache_control: "ephemeral"` и метрикой
  `cache_read_input_tokens` в ответе. (Мы web‑search по умолчанию не включаем, но пример полезен как
  паттерн.)&#x20;

---

## 7) Обработка ошибок инструментов (и почему это у нас почти не актуально)

В классическом цикле tools клиент **выполняет** tool и возвращает `tool_result`; ошибки возвращают
как `tool_result` с `is_error:true`, а модель продолжает диалог. Это касается client‑инструментов
(text editor, computer use) и server‑инструментов (web search, code execution), где есть свои типы
`*_tool_result` и коды ошибок.

**В нашем JSON‑only сценарии:**

- Мы **не** исполняем инструмент → `tool_result` не шлём → ошибка «выполнения» отсутствует как
  класс.
- Единственные ошибки — валидация JSON (Zod) или лимиты токенов.

> Если когда‑то подключим server‑tools, учитываем их потоковые события `server_tool_use`,
> `input_json_delta` и соответствующие `*_tool_result` + биллинг.

---

## 8) max_tokens и наш FSM/Retry

Это **отдельно от tools**. Правила в нашем приложении:

1. Обрабатываем текст пакетами (batch → чанки → предложения), храним порядок через **SID**
   (детерминированная хеш‑схема) — UI строится от **манифеста предложений**; карточки маппятся по
   SID.
2. Если модель вернула **ошибку max_tokens** по одному мини‑пакету, показываем баннер **без
   блокировки** всей сессии: пользователь уже видит пройденные предложения/карточки, а «дырка» ровно
   на месте сбоя.
3. На **Retry** поднимаем лимиты (или дробим мини‑пакет ещё) — при успехе JSON‑ответ валидируется и
   **вклеивается в место**, куда указывает SID/манифест; порядок не ломается.
4. При повторном фейле — баннер с повторной ошибкой, состояние **частично‑готово** остаётся
   доступным.

Это воплощает наши инварианты: **FSM‑first** (idle → submitted → in_progress → ready/failed),
**Manifest‑first**, **JSON‑only + Zod**.

---

## 9) Что с «параллельными вызовами tools»?

Параллельные вызовы **нам не нужны** (ровно один инструмент). Если когда‑то появятся действительно
независимые операции, включаем (`tool_choice:auto|any`, `disable_parallel_tool_use:false`) и строго
соблюдаем формат: все `tool_result` одним `user`‑сообщением, без текста перед ними; иначе Claude
перестанет параллелить. Также помним, что Sonnet 3.7 чаще менее охотно параллелит.

---

## 10) Почему мы **не** включаем специальные Anthropic‑инструменты (кратко)

- **Web search** — отдельное ценообразование, потоковые события и кэш взаимодействуют со всей
  историей; для учебных карточек это не критично. Держим off; включаем только под конкретный режим,
  чётко маркируя UI.&#x20;
- **Code execution** — серверный Python‑контейнер (бета‑хедер), свои результаты/ошибки и даже
  `pause_turn`. Это мощно, но лишне для нашей основной задачи.
- **Text editor / Computer use** — требуют полноценной клиентской реализации (файловые операции /
  управление экраном), безопасность, токенные оверхеды. Не соответствуют текущему ТЗ.

---

## 11) Встраивание в наш код: чек‑лист

**Конфиг (/config/llm.json):**

- `tools.enabled: true`
- `tools.emitToolName: "emit_flashcards"`
- `tools.disableParallel: true`
- `tool_choice: "tool"`
- `betas: []` (по умолчанию; web‑search/code‑exec/fine‑grained — только за флагом)
- `maxTokens`, `retry.maxTokensBump`, `chunking.maxSentences`, `chunking.minSentences=1` (для
  single‑sentence ретрая)

**Адаптер запроса:**

- Добавляет `tools: [emit_flashcards]` в каждый вызов batches/messages.
- Стабилизирует `tool_choice` и не меняет без причины (ради кэша).&#x20;
- `disable_parallel_tool_use: true`.&#x20;

**Парсер ответа:**

- Находит первый `content[type=="tool_use"][name=="emit_flashcards"]`, берёт `input` →
  Zod‑валидация.
- Вклеивает данные в стор через SID‑агрегацию (порядок = манифест).

**FSM и Error UX:**

- `429/413/500/…` — экспоненциальный backoff + honor Retry‑After (см. наши best practices).
- `max_tokens` — баннер + частичная готовность + управляемый Retry (см. п. 8).
- Любой JSON‑миссматч — баннер «Bad JSON» + авто‑повтор с ужесточением инструкций.

---

## 12) Мини‑примеры

### 12.1 Вызов (TypeScript‑псевдо)

```ts
const tools = [{
  name: "emit_flashcards",
  description: "Return flashcards as strict JSON. No text elsewhere.",
  input_schema: /* как в §4.1 */
}];

const resp = await anthropic.messages.create({
  model, max_tokens,
  tools,
  tool_choice: { type: "tool", name: "emit_flashcards" },
  disable_parallel_tool_use: true,
  messages: [
    { role: "system", content: systemPrompt },
    { role: "user", content: userText /* + манифест/подсказки */ }
  ]
});
```

### 12.2 Парсинг

```ts
const toolUse = resp.content.find((b) => b.type === 'tool_use' && b.name === 'emit_flashcards');
const payload = zFlashcardsSchema.parse(toolUse?.input);
```

---

## 13) Примечания на будущее (если решим расширяться)

- **Streaming tool‑params**: включать только с защитой от частичного JSON.&#x20;
- **Параллелизм**: если нужен — следовать требованиям форматирования результатов; иначе Claude
  перестанет параллелить.&#x20;
- **Web‑search + кэш**: пример многоходового кэша в доке; учитывать биллинг `server_tool_use`.&#x20;
- **Code execution**: бета‑хедер, контейнер, `pause_turn`, собственные ошибки.&#x20;

---

### Ссылочные опоры из доков (встроены по разделам)

- Обзор/JSON‑mode/клиент vs сервер tools/параллельные вызовы/опциональность tool_result:
- «Форсировать» выбор инструмента, эффекты `tool_choice` на кэш:&#x20;
- Отключение параллельности:&#x20;
- Web‑search: поток/кэш/биллинг:&#x20;
- Code‑execution: контейнер/результаты/ошибки/`pause_turn`:
- Fine‑grained streaming и риск неполного JSON:&#x20;
- Text editor/Computer use — требования, токенные накладные расходы и риски:
- Наши инварианты (FSM, JSON‑only+Zod):

---

## TL;DR (для Codex/AGENT)

- **Один кастом‑tool `emit_flashcards`**, `tool_choice: tool`, `disable_parallel_tool_use:true`,
  **streaming off**.
- Читаем `tool_use.input` → Zod → кладём по SID в манифест; **`tool_result` не шлём**.
- Prompt Cache держим стабильным (не трогаем `tool_choice`).
- `max_tokens`: частичный успех + баннер, Retry поднимает лимиты/дробит, порядок сохраняет **SID**.
- Server‑tools выключены по умолчанию; включать осознанно и с форматными требованиями.
